// Code generated by MockGen. DO NOT EDIT.
// Source: ../pkg/repositories/types.go

// Package repositories is a generated GoMock package.
package repositories

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	models "github.com/guidomantilla/go-feather-api-sample/pkg/models"
	sqlx "github.com/jmoiron/sqlx"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// CreateAccessControlList mocks base method.
func (m *MockRepository) CreateAccessControlList(ctx context.Context, tx *sqlx.Tx, acl *models.AuthAccessControlList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAccessControlList", ctx, tx, acl)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateAccessControlList indicates an expected call of CreateAccessControlList.
func (mr *MockRepositoryMockRecorder) CreateAccessControlList(ctx, tx, acl interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessControlList", reflect.TypeOf((*MockRepository)(nil).CreateAccessControlList), ctx, tx, acl)
}

// CreateResource mocks base method.
func (m *MockRepository) CreateResource(ctx context.Context, tx *sqlx.Tx, resource *models.AuthResource) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateResource", ctx, tx, resource)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateResource indicates an expected call of CreateResource.
func (mr *MockRepositoryMockRecorder) CreateResource(ctx, tx, resource interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateResource", reflect.TypeOf((*MockRepository)(nil).CreateResource), ctx, tx, resource)
}

// CreateRole mocks base method.
func (m *MockRepository) CreateRole(ctx context.Context, tx *sqlx.Tx, role *models.AuthRole) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRole", ctx, tx, role)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateRole indicates an expected call of CreateRole.
func (mr *MockRepositoryMockRecorder) CreateRole(ctx, tx, role interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRole", reflect.TypeOf((*MockRepository)(nil).CreateRole), ctx, tx, role)
}

// CreateUser mocks base method.
func (m *MockRepository) CreateUser(ctx context.Context, tx *sqlx.Tx, user *models.AuthUser) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, tx, user)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockRepositoryMockRecorder) CreateUser(ctx, tx, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockRepository)(nil).CreateUser), ctx, tx, user)
}

// ExistsPrincipalByParams mocks base method.
func (m *MockRepository) ExistsPrincipalByParams(ctx context.Context, tx *sqlx.Tx, username, role, application, resource, permission string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsPrincipalByParams", ctx, tx, username, role, application, resource, permission)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ExistsPrincipalByParams indicates an expected call of ExistsPrincipalByParams.
func (mr *MockRepositoryMockRecorder) ExistsPrincipalByParams(ctx, tx, username, role, application, resource, permission interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsPrincipalByParams", reflect.TypeOf((*MockRepository)(nil).ExistsPrincipalByParams), ctx, tx, username, role, application, resource, permission)
}

// ExistsPrincipalByUsernameAndApplication mocks base method.
func (m *MockRepository) ExistsPrincipalByUsernameAndApplication(ctx context.Context, tx *sqlx.Tx, username, application string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsPrincipalByUsernameAndApplication", ctx, tx, username, application)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExistsPrincipalByUsernameAndApplication indicates an expected call of ExistsPrincipalByUsernameAndApplication.
func (mr *MockRepositoryMockRecorder) ExistsPrincipalByUsernameAndApplication(ctx, tx, username, application interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsPrincipalByUsernameAndApplication", reflect.TypeOf((*MockRepository)(nil).ExistsPrincipalByUsernameAndApplication), ctx, tx, username, application)
}

// FindPrincipalByUsernameAndApplication mocks base method.
func (m *MockRepository) FindPrincipalByUsernameAndApplication(ctx context.Context, tx *sqlx.Tx, username, application string) ([]models.AuthPrincipal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindPrincipalByUsernameAndApplication", ctx, tx, username, application)
	ret0, _ := ret[0].([]models.AuthPrincipal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindPrincipalByUsernameAndApplication indicates an expected call of FindPrincipalByUsernameAndApplication.
func (mr *MockRepositoryMockRecorder) FindPrincipalByUsernameAndApplication(ctx, tx, username, application interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPrincipalByUsernameAndApplication", reflect.TypeOf((*MockRepository)(nil).FindPrincipalByUsernameAndApplication), ctx, tx, username, application)
}
